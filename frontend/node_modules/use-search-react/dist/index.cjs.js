'use strict';

var React = require('react');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Retrieves the value of a nested field from an object using a dot notation path.
 * @param item The object to search within.
 * @param field The dot notation path to the field (e.g., "user.name").
 * @returns The value of the field, or `undefined` if the field does not exist.
 */
function getFieldValue(item, field) {
    var keys = field.split(/[\.\[\]]/).filter(Boolean); // Split the field path into keys
    var value = item;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (value == null)
            return null; // If the value is null or undefined, return null
        value = value[key]; // Traverse the object
    }
    return value; // Return the final value
}

/**
 * Matches a value against a query using a specified strategy.
 * @param value The value to match against.
 * @param query The search query.
 * @param matchType The matching strategy (e.g., "contains", "startsWith", "exact").
 * @param caseSensitive Whether the match is case-sensitive.
 * @returns `true` if the value matches the query, otherwise `false`.
 */
function matchValue(value, query, matchType, caseSensitive) {
    var normalizedValue = caseSensitive ? value : value.toLowerCase();
    var normalizedQuery = caseSensitive ? query : query.toLowerCase();
    switch (matchType) {
        case "exact":
            return normalizedValue === normalizedQuery;
        case "startsWith":
            return normalizedValue.startsWith(normalizedQuery);
        case "endsWith":
            return normalizedValue.endsWith(normalizedQuery);
        case "contains":
            return normalizedValue.includes(normalizedQuery);
        default:
            throw new Error("Unsupported match type: ".concat(matchType));
    }
}

/**
 * A custom debounce hook.
 * @param value The value to debounce.
 * @param delay The debounce delay in milliseconds.
 * @returns The debounced value.
 */
var useDebounce = function (value, delay) {
    var _a = React.useState(value), debouncedValue = _a[0], setDebouncedValue = _a[1];
    React.useEffect(function () {
        var timeoutId = setTimeout(function () {
            setDebouncedValue(value);
        }, delay);
        return function () { return clearTimeout(timeoutId); };
    }, [value, delay]);
    return debouncedValue;
};

/**
 * Normalizes a string based on case sensitivity.
 */
function normalizeCase(value, caseSensitive) {
    return caseSensitive ? value : value.toLowerCase();
}
/**
 * Converts a value to a string, handling numbers, booleans, and dates.
 */
function convertToString(value) {
    if (value instanceof Date) {
        return value.toISOString();
    }
    if (typeof value === "boolean") {
        return value ? "true" : "false";
    }
    return String(value);
}
/**
 * Recursively extracts all keys from an object (including nested keys).
 */
function getAllKeys(item, threshold, prefix) {
    if (prefix === undefined) { prefix = ""; }
    if (item == null || typeof item !== "object") {
        return [];
    }
    var fields = [];
    var keys = Object.keys(item);
    for (var i = 0; i < keys.length && fields.length < threshold; i++) {
        var key = keys[i];
        var value = item[key];
        var fieldPath = prefix ? "".concat(prefix, ".").concat(key) : key;
        if (Array.isArray(value)) {
            for (var j = 0; j < value.length && fields.length < threshold; j++) {
                var arrayItem = value[j];
                if (typeof arrayItem === "object" &&
                    arrayItem !== null &&
                    !(arrayItem instanceof Date)) {
                    fields.push.apply(fields, getAllKeys(arrayItem, threshold - fields.length, "".concat(fieldPath, "[").concat(j, "]")));
                }
                else {
                    fields.push("".concat(fieldPath, "[").concat(j, "]"));
                }
            }
        }
        else if (value instanceof Date) {
            // Directly add date fields
            fields.push(fieldPath);
        }
        else if (typeof value === "object" && value !== null) {
            fields.push.apply(fields, getAllKeys(value, threshold - fields.length, fieldPath));
        }
        else {
            fields.push(fieldPath);
        }
    }
    return fields;
}

/**
 * Built-in fuzzy search algorithms.
 */
/**
 * Levenshtein Distance-based fuzzy search.
 * @param value The target string.
 * @param query The search query.
 * @returns A score between 0 and 1.
 */
var levenshteinFuzzySearch = function (value, query) {
    var valueLength = value.length;
    var queryLength = query.length;
    if (queryLength === 0)
        return 1; // Empty query matches everything
    var distance = levenshteinDistance(value.toLowerCase(), query.toLowerCase());
    var maxDistance = Math.max(valueLength, queryLength);
    return 1 - distance / maxDistance;
};
/**
 * Jaro-Winkler Distance-based fuzzy search.
 * @param value The target string.
 * @param query The search query.
 * @returns A score between 0 and 1.
 */
var jaroWinklerFuzzySearch = function (value, query) {
    return jaroWinklerDistance(value.toLowerCase(), query.toLowerCase());
};
/**
 * N-Gram-based fuzzy search.
 * @param value The target string.
 * @param query The search query.
 * @returns A score between 0 and 1.
 */
var nGramFuzzySearch = function (value, query) {
    var n = 2; // Bigram by default
    var valueGrams = generateNGrams(value.toLowerCase(), n);
    var queryGrams = generateNGrams(query.toLowerCase(), n);
    var intersection = valueGrams.filter(function (gram) { return queryGrams.includes(gram); });
    return intersection.length / Math.max(valueGrams.length, queryGrams.length);
};
// Helper function to calculate Levenshtein distance
var levenshteinDistance = function (a, b) {
    var matrix = Array.from({ length: a.length + 1 }, function () {
        return Array.from({ length: b.length + 1 }, function () { return 0; });
    });
    for (var i = 0; i <= a.length; i++)
        matrix[i][0] = i;
    for (var j = 0; j <= b.length; j++)
        matrix[0][j] = j;
    for (var i = 1; i <= a.length; i++) {
        for (var j = 1; j <= b.length; j++) {
            var cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // Deletion
            matrix[i][j - 1] + 1, // Insertion
            matrix[i - 1][j - 1] + cost // Substitution
            );
        }
    }
    return matrix[a.length][b.length];
};
// Helper function to calculate Jaro-Winkler distance
var jaroWinklerDistance = function (a, b) {
    var jaroDistance = calculateJaroDistance(a, b);
    var prefixScale = 0.1; // Scaling factor for common prefix
    var prefixLength = getCommonPrefixLength(a, b, 4);
    return jaroDistance + prefixLength * prefixScale * (1 - jaroDistance);
};
var calculateJaroDistance = function (a, b) {
    var matchDistance = Math.floor(Math.max(a.length, b.length) / 2) - 1;
    var aMatches = new Array(a.length).fill(false);
    var bMatches = new Array(b.length).fill(false);
    var matches = 0;
    var transpositions = 0;
    for (var i = 0; i < a.length; i++) {
        var start = Math.max(0, i - matchDistance);
        var end = Math.min(i + matchDistance + 1, b.length);
        for (var j = start; j < end; j++) {
            if (!bMatches[j] && a[i] === b[j]) {
                aMatches[i] = true;
                bMatches[j] = true;
                matches++;
                break;
            }
        }
    }
    if (matches === 0)
        return 0;
    var k = 0;
    for (var i = 0; i < a.length; i++) {
        if (aMatches[i]) {
            while (!bMatches[k])
                k++;
            if (a[i] !== b[k])
                transpositions++;
            k++;
        }
    }
    return ((matches / a.length +
        matches / b.length +
        (matches - transpositions / 2) / matches) /
        3);
};
var getCommonPrefixLength = function (a, b, maxLength) {
    var prefixLength = 0;
    while (prefixLength < maxLength && a[prefixLength] === b[prefixLength]) {
        prefixLength++;
    }
    return prefixLength;
};
// Helper function to generate N-Grams
var generateNGrams = function (str, n) {
    var grams = [];
    for (var i = 0; i <= str.length - n; i++) {
        grams.push(str.slice(i, i + n));
    }
    return grams;
};

/**
 * A custom React hook for searching and filtering data.
 * @template T The type of data being searched.
 * @param data The data to search through.
 * @param query The search query.
 * @param debounceTimeOrFeature Either the debounce time (number) or the first search feature.
 * @param features Additional search features (e.g., filter, search).
 * @returns The filtered and searched data.
 */
function useSearch(data, query, debounceTimeOrFeature) {
    var features = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        features[_i - 3] = arguments[_i];
    }
    // Validate inputs
    if (data == null) {
        console.warn("`data` is null or undefined. Returning an empty array.");
        return [];
    }
    if (typeof query !== "string") {
        throw new Error("`query` must be a string.");
    }
    // Determine if the third argument is a number (debounceTime) or a feature
    var debounceTime;
    var allFeatures;
    if (typeof debounceTimeOrFeature === "number") {
        // If the third argument is a number, use it as the debounce time
        debounceTime = debounceTimeOrFeature;
        allFeatures = features;
    }
    else {
        // If the third argument is not a number, treat it as the first feature
        debounceTime = 150; // Default debounce time
        allFeatures = debounceTimeOrFeature
            ? __spreadArray([debounceTimeOrFeature], features, true) : features;
    }
    // If no features are provided, return the original data
    if (!allFeatures || allFeatures.length === 0) {
        console.warn("No search features provided. Returning the original data.");
        return Array.isArray(data) ? data : [data];
    }
    // Use the custom debounce hook with the specified or default timing
    var debouncedQuery = useDebounce(query, debounceTime);
    return React.useMemo(function () {
        // Convert data to an array if it isn't already
        var dataArray = Array.isArray(data) ? data : [data];
        try {
            // Apply each feature to the data array
            return allFeatures.reduce(function (acc, feature) { return feature(acc, debouncedQuery); }, dataArray);
        }
        catch (error) {
            console.error("Error applying search features:", error);
            return dataArray; // Return original data in case of errors
        }
    }, [data, debouncedQuery, allFeatures]);
}

// Define valid MatchStrategy values for runtime validation
var validMatchStrategies = [
    "exact",
    "startsWith",
    "endsWith",
    "contains",
    "fuzzy",
];
/**
 * Creates a search function that filters data based on the provided options and query.
 * @param options Configuration for search behavior.
 * @returns A function that takes data and a query, returning a filtered array.
 */
var search = function (options) {
    if (options === undefined) { options = {
        match: "contains",
        caseSensitive: false,
        objectToStringThreshold: 10,
    }; }
    var _a = options.match, match = _a === undefined ? "contains" : _a, fields = options.fields, _b = options.caseSensitive, caseSensitive = _b === undefined ? false : _b, _c = options.objectToStringThreshold, objectToStringThreshold = _c === undefined ? 10 : _c, _d = options.fuzzyOptions, fuzzyOptions = _d === undefined ? {
        threshold: 0.4,
        fuzzySearchFn: levenshteinFuzzySearch,
    } : _d;
    // Validate fields
    if (fields && typeof fields !== "string" && !Array.isArray(fields)) {
        throw new Error("Invalid fields: ".concat(fields, ". Must be a string, an array of strings, or undefined."));
    }
    // Validate match
    if (match &&
        typeof match !== "function" &&
        !validMatchStrategies.includes(match)) {
        throw new Error("Invalid match: ".concat(match, ". Must be a MatchStrategy, a function, or undefined."));
    }
    return function (data, query) {
        if (data == null || query == null) {
            return data;
        }
        var trimmedQuery = String(query).trim();
        if (trimmedQuery === "") {
            return data;
        }
        var normalizedQuery = normalizeCase(trimmedQuery, caseSensitive);
        return data.filter(function (item) {
            var fieldsArray = fields
                ? Array.isArray(fields)
                    ? fields
                    : [fields]
                : getAllKeys(item, objectToStringThreshold);
            return fieldsArray.some(function (field) {
                var _a;
                var fieldValue = getFieldValue(item, field);
                if (fieldValue == null)
                    return false;
                var stringValue = convertToString(fieldValue);
                var normalizedValue = normalizeCase(stringValue, caseSensitive);
                // Handle custom matching function
                if (typeof match === "function") {
                    return match(field, stringValue, normalizedQuery);
                }
                // Handle fuzzy search
                if (match === "fuzzy") {
                    var fuzzySearchFn = fuzzyOptions.fuzzySearchFn || levenshteinFuzzySearch;
                    var threshold = (_a = fuzzyOptions.threshold) !== null && _a !== undefined ? _a : 0.6;
                    var score = fuzzySearchFn(normalizedValue, normalizedQuery);
                    return score >= threshold;
                }
                // Handle predefined MatchStrategy
                return matchValue(normalizedValue, normalizedQuery, match, caseSensitive);
            });
        });
    };
};

/**
 * Creates a filter function that filters data based on the provided conditions.
 * @template T The type of data being filtered.
 * @param options Configuration for filtering behavior.
 * @returns A function that takes data and a query, returning a filtered array.
 */
var filter = function (options) {
    var conditions = options.conditions, _a = options.caseSensitive, caseSensitive = _a === undefined ? false : _a, _b = options.missingFieldBehavior, missingFieldBehavior = _b === undefined ? "skip" : _b;
    // Validate missingFieldBehavior
    if (!["skip", "exclude", "throw"].includes(missingFieldBehavior)) {
        throw new Error("Invalid missingFieldBehavior: ".concat(missingFieldBehavior, ". Must be one of \"skip\", \"exclude\", or \"throw\"."));
    }
    // Validate conditions
    if (!conditions || !Array.isArray(conditions) || conditions.length === 0) {
        console.warn("No conditions provided for filtering. Returning original data.");
        return function (data) { return data; };
    }
    return function (data, _query) {
        if (data == null) {
            return [];
        }
        return data.filter(function (item) {
            return conditions.every(function (condition) {
                var field = condition.field, operator = condition.operator, value = condition.value;
                // Validate condition
                if (!field || !operator) {
                    console.warn("Invalid condition: field or operator is missing. Skipping condition.");
                    return true;
                }
                var fieldValue = getFieldValue(item, field);
                // Handle missing fields
                if (fieldValue === undefined) {
                    switch (missingFieldBehavior) {
                        case "skip":
                            return true;
                        case "exclude":
                            return false;
                        case "throw":
                            throw new Error("Field \"".concat(field, "\" does not exist in the data."));
                    }
                }
                // Handle null or undefined field values
                if (fieldValue == null) {
                    return operator === "isNull";
                }
                // Convert field value and query value to strings for comparison
                var stringValue = String(fieldValue);
                var normalizedValue = normalizeCase(stringValue, caseSensitive);
                var normalizedQuery = normalizeCase(String(value), caseSensitive);
                // Apply the operator
                switch (operator) {
                    case "equals":
                        return normalizedValue === normalizedQuery;
                    case "notEquals":
                        return normalizedValue !== normalizedQuery;
                    case "contains":
                        return normalizedValue.includes(normalizedQuery);
                    case "notContains":
                        return !normalizedValue.includes(normalizedQuery);
                    case "greaterThan":
                        return Number(fieldValue) > Number(value);
                    case "lessThan":
                        return Number(fieldValue) < Number(value);
                    case "greaterThanOrEquals":
                        return Number(fieldValue) >= Number(value);
                    case "lessThanOrEquals":
                        return Number(fieldValue) <= Number(value);
                    case "isNull":
                        return fieldValue == null;
                    default:
                        throw new Error("Unsupported operator: ".concat(operator));
                }
            });
        });
    };
};

/**
 * Creates a sorting function that sorts data based on the provided options.
 * @template T The type of data being sorted.
 * @param options Configuration for sorting behavior.
 * @param options.field The field to sort by.
 * @param options.order The sort order. Can be "asc" (ascending) or "desc" (descending). Defaults to "asc".
 * @param options.nullsFirst Whether to place null/undefined values first. Defaults to false.
 * @returns A function that takes data and returns a sorted array.
 */
var sort = function (options) {
    var field = options.field, _a = options.order, order = _a === undefined ? "asc" : _a, _b = options.nullsFirst, nullsFirst = _b === undefined ? false : _b;
    return function (data, _query) {
        return __spreadArray([], data, true).sort(function (a, b) {
            var aValue = a[field];
            var bValue = b[field];
            // Handle null/undefined values
            if (aValue == null && bValue == null)
                return 0;
            if (aValue == null)
                return nullsFirst ? -1 : 1;
            if (bValue == null)
                return nullsFirst ? 1 : -1;
            // Compare values
            if (aValue < bValue)
                return order === "asc" ? -1 : 1;
            if (aValue > bValue)
                return order === "asc" ? 1 : -1;
            return 0;
        });
    };
};

/**
 * Creates a pagination function that paginates data based on the provided options.
 * @template T The type of data being paginated.
 * @param options Configuration for pagination behavior.
 * @param options.pageSize The number of items per page. Defaults to 10.
 * @param options.page The current page number. Defaults to 1.
 * @returns A function that takes data and returns a paginated array.
 */
var paginate = function (options) {
    var _a = options.pageSize, pageSize = _a === undefined ? 10 : _a, _b = options.page, page = _b === undefined ? 1 : _b;
    return function (data, _query) {
        if (pageSize <= 0 || page <= 0) {
            console.warn("pageSize and page must be positive numbers. Returning empty array.");
            return [];
        }
        var startIndex = (page - 1) * pageSize;
        var endIndex = startIndex + pageSize;
        return data.slice(startIndex, endIndex);
    };
};

/**
 * Creates a grouping function that groups data based on the provided options.
 * @template T The type of data being grouped.
 * @param options Configuration for grouping behavior.
 * @param options.field The field to group by.
 * @param options.defaultGroupKey The default group key for items with missing or null fields. Defaults to "Other".
 * @returns A function that takes data and returns a grouped array.
 */
var group = function (options) {
    var field = options.field, _a = options.defaultGroupKey, defaultGroupKey = _a === undefined ? "Other" : _a;
    return function (data, _query) {
        var groups = new Map();
        data.forEach(function (item) {
            var groupKey = item[field] || defaultGroupKey;
            if (!groups.has(groupKey)) {
                groups.set(groupKey, []);
            }
            groups.get(groupKey).push(item);
        });
        console.log(groups.values());
        return Array.from(groups.values()).flat();
    };
};

exports.convertToString = convertToString;
exports.filter = filter;
exports.getAllKeys = getAllKeys;
exports.getFieldValue = getFieldValue;
exports.group = group;
exports.jaroWinklerFuzzySearch = jaroWinklerFuzzySearch;
exports.levenshteinFuzzySearch = levenshteinFuzzySearch;
exports.matchValue = matchValue;
exports.nGramFuzzySearch = nGramFuzzySearch;
exports.normalizeCase = normalizeCase;
exports.paginate = paginate;
exports.search = search;
exports.sort = sort;
exports.useDebounce = useDebounce;
exports.useSearch = useSearch;
//# sourceMappingURL=index.cjs.js.map
